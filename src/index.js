import React from 'react';
import ReactDOM from 'react-dom';
import Button from '@material-ui/core/Button';
import Post from './Post.js'
import PropTypes from 'prop-types';
import {fade, makeStyles} from '@material-ui/core/styles';
import IconButton from '@material-ui/core/IconButton';
import Drawer from "@material-ui/core/Drawer";
import Divider from "@material-ui/core/Divider";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import ChevronLeftIcon from "@material-ui/icons/ChevronLeft";
import AppBar from '@material-ui/core/AppBar';
import Toolbar from '@material-ui/core/Toolbar';
import MenuIcon from '@material-ui/icons/Menu';
import CssBaseline from "@material-ui/core/CssBaseline";
import Card from '@material-ui/core/Card';
import CardActions from '@material-ui/core/CardActions';
import CardContent from '@material-ui/core/CardContent';

import { createMuiTheme } from '@material-ui/core/styles';
import {MuiThemeProvider} from "@material-ui/core";
import Paper from '@material-ui/core/Paper';
import Typography from '@material-ui/core/Typography';
import Grid from '@material-ui/core/Grid';
import clsx from "clsx";
import Graph from './react-sigm-changed';
import Scatter_Graph from './scatter.js'

import BarGraph from './bar.js';

//import './style.css'

import Slide from '@material-ui/core/Slide';
import useScrollTrigger from '@material-ui/core/useScrollTrigger';

function HideOnScroll(props) {
  const { children, window } = props;
  // Note that you normally won't need to set the window ref as useScrollTrigger
  // will default to window.
  // This is only being set here because the demo is in an iframe.
  const trigger = useScrollTrigger({ target: window ? window() : undefined });

  return (
    <Slide appear={false} direction="down" in={!trigger}>
      {children}
    </Slide>
  );
}

HideOnScroll.propTypes = {
  children: PropTypes.element.isRequired,
  /**
   * Injected by the documentation to work in an iframe.
   * You won't need it on your project.
   */
  window: PropTypes.func,
};


const drawerWidth = 300;

const theme = createMuiTheme({
  palette: {
    primary: { // works
      main: "#212121",
      contrastText: "#9a9a9a",
    },
    secondary: { // works
      main: "#17a2bc",
      contrastText: "#1de9b6", //indigo[300]
    },

    third: { // works
      main: "#1de9b6",
      contrastText: "#1de9b6",
    },
  },
  typography:{
    fontSize: 13,
  },
  spacing:4,
});

const useStyles = makeStyles(theme => ({
  grow: {
    flexGrow: 1,
  },
  title: {
    display: 'none',
    [theme.breakpoints.up('sm')]: {
      display: 'block',
    },
  },
  sectionDesktop: {
    display: 'none',
    [theme.breakpoints.up('md')]: {
      display: 'flex',
    },
  },
  sectionMobile: {
    display: 'flex',
    [theme.breakpoints.up('md')]: {
      display: 'none',
    },
  },

  // From PermanentDrawer
  root: {
    display: 'flex'
  },
  appBar: {
    position:'fixed',
    transition: theme.transitions.create(['margin', 'width'], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
    height: "65px",
  },
  appBarShift: {
    width: `calc(100% - ${drawerWidth}px)`,
    marginLeft: drawerWidth,
    transition: theme.transitions.create(['margin', 'width'], {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen,
    }),
  },

  menuButton: {
    marginRight: theme.spacing(2),
  },
  hide: {
    display: 'none',
  },
  drawer: {
    width: drawerWidth,
    flexShrink: 0,
  },
  // Drawer Setting
  drawerPaper: {
    background:"#283593",
    width: drawerWidth,
  },
  drawerHeader: {
    display: 'flex',
    alignItems: 'center',
    padding: theme.spacing(0, 1),
    ...theme.mixins.toolbar,
  },
  content: {
    flexGrow: 1,
    paddingLeft: '5%',
    paddingRight: '5%',
    paddingTop: '0%',
    paddingBottom: '10%',
    transition: theme.transitions.create('margin', {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
  },
  contentShift: {
    transition: theme.transitions.create('margin', {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen,
    }),
    marginLeft: 0,
  },
  Title:{
    fontSize:20,
    fontWeight:600,
    marginLeft:30,
    fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif"
  },
  TitleLink:{
    fontSize:20,
    fontWeight:600,
    marginLeft:30,
    marginTop:20,
    paddingBottom:30,
    fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif"
  },
  mainFeaturedPost: {
    position: 'relative',
    backgroundColor: theme.palette.grey[800],
    color: theme.palette.common.white,
    marginBottom: theme.spacing(4),
    backgroundImage: 'url(https://source.unsplash.com/random)',
    backgroundSize: 'cover',
    backgroundRepeat: 'no-repeat',
    backgroundPosition: 'center',
  },
  overlay: {
    position: 'absolute',
    top: 0,
    bottom: 0,
    right: 0,
    left: 0,
    backgroundColor: 'rgba(0,0,0,.3)',
  },
  mainFeaturedPostContent: {
    position: 'relative',
    padding: theme.spacing(3),
    [theme.breakpoints.up('md')]: {
      padding: theme.spacing(6),
      paddingRight: 0,
    },
  },
  paper:{
    paddingLeft: '5%',
    paddingRight: '5%',
    fontWeight: 400,
  }
}));



  var initial = true
  var histData
  var sDataAvg = {}
  var sDataMax = {}

function App(props) {
  const classes = useStyles();
  const [open, setOpen] = React.useState(false);
  


  const [fetchResult, setfetchResult] = React.useState(null);
  const [ScatterRes, setScatterRes] = React.useState(null);
  const [ScatterRes1, setScatterRes1] = React.useState(null);
  const [ScatterRes2, setScatterRes2] = React.useState(null);
  const [HistData, setHistData] = React.useState(null);

  const edge_distinct = (value, index, self) =>{
    //console.log(self)
    //console.log(value)
    //console.log(index)
    for(var l = 0; l < self.length; l++){
        if((value.source === self[l].source) && (value.target === self[l].target)){
            //console.log(index + " " + l)
            return (l === index)
        }
    }
}

var nodes = []
var edges = []

  if(initial){
    const url = "test7.json"
    const url2 = "tnse_test.json"
    fetch(url)
        .then(resp => resp.json())
        .then(data => {
          /*var edges_to_use = []
          var used_edges = {}
          for(var i = 0; i < data.edges.length; i++){
            if(!used_edges.hasOwnProperty(data.edges[i].source)){
              used_edges[data.edges[i].source] = {}
              used_edges[data.edges[i].source][data.edges[i].target] = 1
              edges_to_use = edges_to_use.concat(data.edges[i])
            }
            else{
              if(!used_edges[data.edges[i].source].hasOwnProperty(data.edges[i].target)){
                used_edges[data.edges[i].source][data.edges[i].target] = 1
                edges_to_use = edges_to_use.concat(data.edges[i])
              }
            }

          }*/
        
          console.log(data)
          //console.log(data.edges.filter(edge_distinct))
          //for(var i = 0; i < data.nodes.length; i++){
          //  data.nodes[i].label = data.nodes[i].id
          //}
          nodes = data.nodes
          edges = data.edges

        })
        .then(data =>{
          var urlHist = "data_hist.json"
          fetch(urlHist)
          .then(resp => resp.json())
          .then(data3 => {
            console.log(data3.data)
            histData = data3.data
          })
        .then(data =>{
          var urlAvgB = "weight_v_avg_benign-1.json"
          console.log(urlAvgB.length)
          fetch(urlAvgB)
          .then(resp => resp.json())
          .then(data5 => {
            sDataAvg.benign = data5
          }).then(data =>{
            var urlAvgM = "weight_v_avg_malware-1.json"
            console.log(urlAvgM.length)
            fetch(urlAvgM)
            .then(resp => resp.json())
            .then(data4 => {
              sDataAvg.malware = data4
              
            })
            .then(data =>{
              var urlMaxM = "weight_v_max_malware-1.json"
              fetch(urlMaxM)
            .then(resp => resp.json())
            .then(data6 => {
              sDataMax.malware = data6
              
            })
            .then(data =>{
              var urlMaxB = "weight_v_max_benign-1.json"
              fetch(urlMaxB)
            .then(resp => resp.json())
            .then(data7 => {
              sDataMax.benign = data7
              
            })
                 .then(data =>{
  
              fetch(url2)
            .then(resp => resp.json())
            .then(data2 => {
    
    
    
              console.log("Last of Lengths ".concat(data2.malware))
              console.log("Last of Lengths ".concat(data2.benign))
              console.log(data2)
              console.log(sDataAvg)
              
          setScatterRes(data2)

              setHistData(histData)
    
              setScatterRes1({malware:sDataAvg.malware, benign:sDataAvg.benign, average:true})
              setScatterRes2({malware:sDataMax.malware, benign:sDataMax.benign})


              var comp_js = {0: "Malware", 1:"Benign"}

              setfetchResult({
                nodes: nodes,
                edges: edges
              })
              setfetchResult(null)
              setfetchResult({
                nodes: nodes,
                edges: edges
              })
              console.log("Set")
            })
              }
            )
          })
        })
        }) 
        })
      })

      initial = false
  }


  const handleDrawerOpen = () => {
    setOpen(true);
  };

  const handleDrawerClose = () => {
    setOpen(false);

  };

  const binningAlgo = (data, binNum) => {
    var min_val = Math.min(data.value)
    var max_val = Math.max(data.value)
    var bin_length = (max_val-min_val)/binNum
    var bin_data = []
    for(var i = 0; i < binNum; i++){
      bin_data = bin_data.concat({"name": "Bin ".concat(i), count:0})
    }
    for(var j = 0; j < data; j++){
      for(var i = 0; i < binNum; i++){
        if(min_val+(bin_length*(i+1)) > data.value[j]){
          bin_data[i].count += 1
          break
        }
      }
    }

    return bin_data
  }

  return (
    <div>
        <MuiThemeProvider theme={theme}>
        <CssBaseline />
        <HideOnScroll {...props}>
        <AppBar
          id="appbar"
          position="fixed"
          className={classes.appBar}
          style={{backgroundColor:"#ffffff"}}
      >
        <Toolbar>
          <IconButton
              color="inherit"
              aria-label="open drawer"
              onClick={handleDrawerOpen}
              edge="start"
              className={clsx(classes.menuButton, {
                [classes.hide]: open,
              })}
          >
            <MenuIcon />
          </IconButton>

          <Typography className={classes.Title}>
                 Malware Detection
          </Typography>

          </Toolbar>
          </AppBar>
          </HideOnScroll>

          <Drawer
          className={classes.drawer}
          style={{width:drawerWidth}}
          variant="persistent"
          anchor="left"
          color="primary"
          open={open}
          classes={{
            paper: classes.drawerPaper,
          }}
      >
          <div className={classes.drawerHeader}>
            <IconButton onClick={handleDrawerClose} style={{color:"#1de9b6"}}>
              {theme.direction === 'ltr' ? <ChevronLeftIcon /> : <ChevronRightIcon />}
            </IconButton>
            <Typography className={classes.Title} style={{color:"#1de9b6"}} color="third">
                 Sections
          </Typography>
          </div>

          <Divider />
          <Divider />

          <Typography className={classes.TitleLink} color="secondary">
                 <a href="#intro" style={{color:"#86d7f8", textDecoration:"none", paddingBottom:30}}> - Overview</a>
          </Typography>
          <Typography className={classes.TitleLink} color="secondary">
                 <a href="#hindroid" style={{color:"#86d7f8", textDecoration:"none", paddingBottom:30}}> - Hindroid Paper</a>
          </Typography>
          <Typography className={classes.TitleLink} color="secondary">
                 <a href="#scale" style={{color:"#86d7f8", textDecoration:"none", paddingBottom:30}}> - Scalability of Project</a>
          </Typography>
          <Typography className={classes.TitleLink} color="secondary">
                 <a href="#explain" style={{color:"#86d7f8", textDecoration:"none", paddingBottom:30}}> - Explaining Model Explanability</a>
          </Typography>
          <Typography className={classes.TitleLink} color="secondary">
                 <a href="#results" style={{color:"#86d7f8", textDecoration:"none", paddingBottom:30}}> - Results</a>
          </Typography>
          <Typography className={classes.TitleLink} color="secondary">
                 <a href="#related" style={{color:"#86d7f8", textDecoration:"none", paddingBottom:30}}> - Related Work</a>
          </Typography>
          <Divider />
        </Drawer>


        <div style={{margin:40, backgroundColor:"#283593"}} ></div>
        <main className={classes.content} style={{backgroundColor:"#283593"}}>
          <Paper>

          
          <Typography style={{fontSize:"40px", color:"#3a3a4a", textAlign:"center", margin:30, paddingTop:'5%', fontFamily:'Palatino'}} color="secondary">
                      <i> Malware Detection Project </i>

            </Typography>


            <Divider/>
          <div style={{maxWidth: "100%", maxHeight: "20%"}}>
          <img src={"security-challenge.jpg"} style={{width: "70%", height:"70%", paddingTop:'1%', paddingBottom:'1%', paddingLeft:"30%"}}/>
          </div>
          <Divider/>

        <Card className={classes.paper} color="secondary">
          <CardContent>

            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            In order to provide a good service to Android users, Google needs to guarantee their users can download apps without risking their privacy. <br/><br/>
	But check out these statistics:
  <ul>
<li>In the android app store, a prior study showed that 1 in 5 apps in that app store were malware</li>
<li>Last year there were 2 billion detected malware installs that Google stopped</li>
<li>An estimated 1,500 android apps are downloaded per day, it is likely that some are malware</li>
</ul>


Hackers and malware developers are always evolving their methods to try to trick old detection models. Thus detection models need to improve to keep up.

            </Typography>

            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            Malware detection is tricky. There’s two things that make it hard.
<ol> 
  <li>There are many types of malware code very different from other malware code, but the detection model needs to recognize every type as malware code.</li>
<li>Malware code resembles benign (not malware) code.
<ul><li>For example, the same apis was called between adware and a benign app but adware called one api excessively (too many ads).</li></ul></li>
</ol>
</Typography>
</CardContent>
            

            </Card>

            <Typography paragraph id="intro" style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} color="secondary">
                      <i>Overview </i>

            </Typography>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
This section goes over a brief overview of our system implementation from the data collection process, to the model building.

            </Typography>

        <img src="97349953_252876669409151_6666325293965246464_n.png" style={{marginLeft:"16%", width:"70%", height:"70%"}} />


        <Card className={classes.paper} color="secondary">
        <CardContent>

            <Typography paragraph style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} id="hindroid" color="secondary">
                      <i>Hindroid Paper</i>
            </Typography>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            <br/>

          <b>Data collection</b> - We create the benign apps dataset from the APKpure website where the APK’s of the android apps 
          are downloaded. The malware apps dataset is collected from the AMD website. 
          Our training set consists of a total of 2400 apps with 1200 from each category.  
          A downloaded APK file usually contains <i>AndroidManifest.xml</i>, <i>classes.dex</i>, and <i>resources.arsc</i> file; as well as a <i>META-INF</i> and <i>res</i> folder. The .dex file is an 
          unreadable file and needs to be converted into a readable file. Using the APK tool kit we extract smali files for each app that is human readable 
          and can be analysed to find out if an app is malware or benign. 


<br/>
<br/>
            <b>Decompile</b> - We first decompile the .dex files into smali files using the APK tool kit 
<br/>
<br/>
<b>Cleaning and extractions</b> - Once we have the smali files we extract the 
unique API’s from each app, remove certain API’s that aren't detrimental in the classification 
tasks and store them in three different dictionary structures, each appropriate for the task in hand.  
API calls are used by the Android apps in order to access operating system functionality and system resources. 
Therefore, they can be used as representations of the behaviors of an Android app.  We parse through all the .smali files 
in the apps and extract all the API’s that are present in a code block. An example of an API - <i>Ljava/lang/Runtime;</i> -> <i>getRuntime() Ljava/lang/Runtime</i>
<br/>
<b>Graph structures </b> - Once we have all the extracted API’s in the three different dictionary structures, we used each of them to create three different graph structures that are used to create the kernels. Three different graph structures A,B and P are created which are represented as sparse matrices. Each of the structure represents relations between <i>apps</i> and <i>API’S</i> and <i>API’S</i> and <i>APIs</i>
<ul>
<li>A matrix - Sparse matrix where an element represents if an APP contains an API</li>
<li>B matrix  - Sparse matrix where an element represents two API are in the same code block</li>
<li>P matrix -  Sparse matrix where an element represents two API share the same package (Add the graph visualization here)</li>
</ul>

</Typography>

<img src="Kernels.PNG" style={{marginLeft:"16%", width:"70%", height:"70%"}} />


<Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">

<b>Meta-paths</b> - The matrices to create the meta paths which is a way to link the apps together. The meta paths characterize the semantic relatedness of apps and APIs.
<br/>
So in the second example of ABA^T in the image above what the meta-path denotes is that an app that contains an api, and that api is in the same code block with another api and the other API belongs to app2. These metapaths can be considered as kernels to create a multi kernel. 
<br/>


<Grid container color="primary">
        <Grid item md={7} color="inherit"> 
                  <img style={{width:"90%", height:"90%", paddingRight:"5%"}} src="MultiKernel.PNG"/>
                  </Grid>
                  <Grid item md={5} color="inherit"> 
                  <Card>
                    <CardContent>
                    <b>Multi-kernel</b> - A multi kernel is created, which is a combination of all the previous kernels created.  Each of the kernels are first transformed into <i>polynomial kernels</i> which turns it into a sparse matrix making it easier for the model to learn the corresponding weights. Using the <i>Alignf </i>
                  </CardContent>
                  </Card>
                  </Grid>
                </Grid>

<b>Kernel on test set</b> - Similarly as for training set, kernels and multi kernels and created for the test set and the performance for each of the kernels is computed on the test set. 
<br/>
<br/>
<b>Support vector analysis</b> - Once the model has been trained and tested, the Support Vectors and the coefficients assigned to them are investigated. The coefficients are ranked and the most extreme positive and negative coefficients and their vectors are analyzed for any trends or anomalies.

            
</Typography>


<Typography paragraph style={{fontSize:"25px"}} color="primary">
            </Typography>
            </CardContent>

            </Card>


        <Card className={classes.paper} color="secondary">
            <CardContent>

            <Typography paragraph id="scale" style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} color="secondary">
                      <i>Scalability</i>
            </Typography>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            
An important part of our project was scaling up the scope of the project. When using 2400 apps, we noticed that the number of unique API extracted accumulated to around 4.3 millions apps which is not feasible for our implementations. This called for exploring techniques that helped us in reducing the number of unique API whilst keeping the model performance the same. Here are some of the methods that were effective in doing so - 

<ol>
  <li>
We noticed that several smali file names had a $ sign in its name. It is a java naming convention where inner classes are donated with a $ sign. The name of the inner class accompanied the $ sign and if a number accompanied the $ sign it means it was an anonymous inner class. For eg.
<ul>
<li><i>Testouter.smali</i></li>
<li><i>Testouter$inner.smali </i></li>
<li><i>Testouter$1.smali</i></li>
</ul>
	<i>Testouter$inner.smali, Testouter$1.smali are the inner classes</i>
  <br/>
An inner class is usually a private or protected class meaning the API’s call made within these classes will be mostly unique and won't be seen commonly among other API’s. Hence the decision was made to ignore all such files with a $ sign name in it 

</li>

<li>We also noticed that there were two types of method calls, private and public. Applying the same logic as above, we ignore all API calls that occurred between a private code block </li>
<li>Out of the <b>4.3 million</b> unique API’s we noticed that a majority of them only occured in one or a small subset of the total apps. <b>2 million</b> of the API’s were just seen in one app. We then decided to remove all API’s that occured in less than <b>5 apps</b>, which reduced our number of unique API’s just to <b>650k</b>. </li>

<Card className={classes.paper} color="secondary" style={{ textAlign:"center", width:'100%', height:'100%'}}>
                  <CardContent>
          {(HistData === null)? <div/> : 
              <BarGraph data={HistData}></BarGraph>
          }
          </CardContent>
                  </Card>

<li>Lastly, we explored another method involved removing all the API’s that commonly occur in both malware and benign. We did so as we believed that these API’s that were common in both malware and benign won’t be important in making the classification decision. Out of the <b>650k</b> remaining API’s we saw that <b>110k</b> of those APIs were shared among both benign and malware. </li>
</ol>
            </Typography>
            </CardContent>
        </Card>
        <Card className={classes.paper} color="secondary">
            <CardContent>

            <Typography paragraph id="explain" style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} color="secondary">
                      <i>Results</i>
            </Typography>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            Scaling and Improving
<br/>
</Typography>
<img style={{width:"70%", height:"70%"}} src="TableScn.PNG"/>

<Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
In an attempt to confirm if our scalability measures did not impede performance, we ran several different experiments which can be found in the above table. The table contains accuracy and False Positive Rate (FPR), which is the percentage of malware wrongly 
classified as benign, for the models trained on the different kernels. The kernels are created using different API removal thresholds which can be found on the top row on the table 
with the results for that experiment bordered in bold. Across the board we found the best performance and lowest FPR to be the model trained using the multi-kernel algorithm with APIs 
removed from the matrices if they occur in 5 or less apps. We found that the performance of multi-kernel decreases when more APIs are removed which is intuitive based on what we know from the Hindroid paper. 
The paper states that the APIs capture the relationships between apps and therefore are necessary to accurately classify malware. But, we saw when we removed the common APIs and the APIs occurring in 5 or less apps, the APA^T and ABA^T kernels 
performance improved as compared to the experiment where APIs were removed if they occurred in 5 or less apps. This finding is interesting and contradictory to the previously stated information from Hindroid. However, through these experiments we were 
able to show that the dimensionality of the A, B, and P matrices can be reduced without sacrificing performance.
            </Typography>
 
            <Grid container color="primary">
                <Grid item md={6} color="inherit"> 
                <Card className={classes.paper} color="secondary" style={{marginLeft:0, textAlign:"center"}}>

                {(fetchResult === null)? <div/> : 
                  <Graph data={fetchResult}/>
              }
                  
                  </Card>
                </Grid>
                <Grid item md={6} color="inherit"> 
                  <Card className={classes.paper} color="secondary" style={{ textAlign:"center", width:'100%', height:'100%'}}>
                  DRAG THE SLIDER!
                  <br/>
                  Here is a reprsentation of one of our graphs. The nodes grouped together
                  represent apps that share the same api calls. The outside blue nodes are the different types of malware.
                They
                  don't share many api calls with other types of malware but instead share api calls with some benign apps.
                  
                  </Card>
                </Grid>
          </Grid>
  
            </CardContent>
        </Card>

        <Typography paragraph id="results" style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} color="secondary">
                      <i>Model Explanability</i>
        </Typography>

        <Card className={classes.paper} color="secondary" style={{ textAlign:"center", width:'100%', height:'100%'}}>
                  <CardContent>
                    <div>SVM weights compared to the Average # of Shared APIs</div>
        {(ScatterRes1 === null)? <div/> : 
                  <Scatter_Graph data={ScatterRes1}/>
              }
              </CardContent>
                  </Card>
         





        <br/>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">

          
            In addition to analyzing the scalability, we analyzed the coefficients for the support vectors of the kernel produced by the Linear SVM model. 
            We found that AA had the highest variation in its coefficients so it’s differences were easier to analyze and easier to visualize. This plot is 
            showing support vectors for the AA^T kernel, their coefficients, and statistics about them. The Y axis of this plot depicts the model coefficient for a 
            given support vector and the X axis depicts the average value of the given support vector. Blue in the plot represents Benign apps and orange represents malware. 
            We found through our research that the distribution and statistics of the support vector are the indicators of model coefficients. Essentially this means, 
            if two support vectors have similar compositions, then they will be weighted in similar ways. This can be seen in the above plot where on the left side, the malware 
            apps are on the lower end and all clustered towards a negative coefficient. The benign apps increase in average vector value and have both positive and negative coefficients but, 
            they are more likely to have a positive coefficient. This can lead to mistakes because occasionally support vectors have similar statistics and distributions meaning they are assigned the 
            wrong coefficient. As can be seen from the plot there are some benign apps assigned a negative weight because of its lower average vector value and vice versa for malware apps.

            </Typography>


        <Card className={classes.paper} color="secondary" style={{ textAlign:"center", width:'100%', height:'100%'}}>
                  <CardContent>
                  <div>SVM weights compared to the Max # of Shared APIs</div>
        {(ScatterRes2 === null)? <div/> : 
                  <Scatter_Graph data={ScatterRes2}/>
              }
              </CardContent>
                  </Card>
         





        <br/>

        <Card>
        <CardContent>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">

          
            The same results discussed previously can be seen from the above plot. This plot is similar to the previous 
            in that it shows the AA^T kernel and model coefficients of support vectors, but it shows the metric of maximum vector value. 
            The similar results can be seen as the lower values are malware apps and given negative coefficients and the higher values are benign 
            apps and given positive coefficients. However, we encounter the same issue of  the benign support vectors having relatively low maximum values and 
            given large negative coefficients. These errors are what can lead to the False Positives, malware apps classified as benign, which could be dangerous is 
            scaling to large sets of data and attempting to ship a commercial product. Since each kernel had this issue of giving incorrect weight to different support vectors, 
            the multi-kernel learning algorithm may help in mitigating these issues because if too many mistakes are made by a certain kernel, it can be given a lower weight.

            </Typography>
            </CardContent>
        </Card>

        <Card className={classes.paper} color="secondary">
            <CardContent>

            <Typography paragraph id="related" style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} color="secondary">
                      <i>Conclusion</i>
            </Typography>
            <Typography paragraph style={{fontSize:"22px", fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            Through our research, we found that it is possible to utilize different metrics to scale the expensive computations of Hindroid without sacrificing 
            performance. In addition, we found that any misclassification and reductions in accuracy may be caused by support vectors of the kernels being too 
            similar in composition. This leads to the ultimate conclusion of the work we’ve done this quarter which is that the multi-kernel learning of a 
            heterogeneous information network is the key in reducing the impact of these similar support vectors. By leveraging the techniques we’ve laid out, 
            we can effectively understand and improve upon the work done in the Hindroid paper to make downloading apps a little bit safer for everyone.

            </Typography>

            </CardContent>
          </Card>

        <Card className={classes.paper} color="secondary">
            <CardContent>

            <Typography paragraph id="related" style={{fontSize:"30px", color:"#02642f", textAlign:"center", paddingTop: '7%'}} color="secondary">
                      <i>Related Work</i>
            </Typography>
            <Typography paragraph style={{fontSize:"22px", paddingBottom: '15%', fontFamily:"Palatino Linotype, Book Antiqua, Palatino, serif", paddingLeft: '12%', paddingRight: '12%', paddingTop: '4%'}} color="primary">
            In recent years, the paper DREBIN (https://www.sec.cs.tu-bs.de/pubs/2014-ndss.pdf)
suggests an app that detects malware and explains why it classifies an app as malware based on
the weights it assigns. It runs static analysis on many apps and features, including whether they
ask for permission, dangerous API calls, and hardware the app tries to access. Then, it embeds
each of these features into its own vectors, each entry for each app. Using an SVM like us it
feeds in these vectors and rates them. It then analyzes high negative weights to reflect on its
performance. And the MaMaDroid paper (https://arxiv.org/pdf/1612.04433.pdf), an android
detection model that detects based on abstracted api calls (using the package or the source name).
It also contains the sequence of the api calls, not just checking if they’re in the same code block.
Thus, it connects sequential packages/abstract APIs being used between apps. The model itself is
based on Markov chains. On the contrary, detection in Hindroid is based on the connectedness of
apps and APIs and contains a broader set of information to potentially capture more thorough
relationships. Which DREBIN doesn’t do. Therefore, doing model explainability with it would
provide a more in depth look at these relationships and the correct classification of broader types
of malware. For the MaMaDroid paper, it contains complicated relationships different from the
features we’ll be using but the Markov chain uses probabilities and focuses more on app
behavior than connections between apps. We won’t be able to (or at least it’ll be hard) to connect
apps that we know to be malware towards new apps without the use of metapaths. By using
metapaths and weights we assign to them, we can understand the model much easier.
The accuracy of the model and contributions of the Hindroid paper are extensive;
however, understanding the exact types of malware it is good or bad at capturing aren’t explored
thoroughly. By looking into the weights of the SVM and the paths taken by the matrices
corresponding to those feature weights, it will add an additional layer of understanding. We
could add more complicated relationships like the MaMaDroid project but there can be some
issues with that. The MaMaDroid seems to work much better than the Hindroid paper for
training and some test sets but much worse on other test sets. It could be overfitting its model
with relationships not representative of the general malware apps (whether a series of packages
are used in a specific sequence). So although this could be a deficiency in the Hindroid paper, we
might not try to complicate the relationships further. However, similar to the MaMaDroid paper
and unlike the Hindroid paper, we will try to abstract api calls by looking closer at the packages
and their relationships along with the source names. This way we can connect more apps
together and assign many more weights in between them. Thereby we can explain the similarities
and differences between more apps than before, through the weights the SVM will assign.
            </Typography>

            <Typography>
          <a style={{textAlign:"center", paddingLeft:"40%"}} href="Project checkpoint 3.pdf">Full Report (CHANGE)</a> <a href="">Github Repository</a>
          </Typography>
            </CardContent>
        </Card>
        </Paper>
        </main>

        </MuiThemeProvider>
    </div>
  );
}




//each are classes
//Classes:
    //.mainFeaturedPost
    //.overlay
    //.mainFreaturedPostContent


ReactDOM.render(<App />, document.getElementById('app'));